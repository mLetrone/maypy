{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MayPy","text":"<p>Pythonic Java Optional API</p> <p> </p> <p>Source Code: https://github.com/MLetrone/maypy</p> <p>documentation: https://mletrone.github.io/maypy/</p> <p>Maypy is python implementation of the well known Java Optional API. It's designed to help you handle potential <code>None</code> values, reducing error from <code>NoneType</code>.</p>"},{"location":"#features","title":"Features :","text":"<ul> <li>Brings functional programming</li> <li>Easy to use</li> <li>Fully typed and compatible with <code>mypy</code> !</li> <li>Lightweight</li> </ul>"},{"location":"#description","title":"Description","text":"<p>It's not rare to handle return from function that maybe either a value or None. Like <code>.get</code> from a dictionary, results from api or ORM etc. With no more <code>if value is None</code> with <code>MayPy</code>, encapsulate your value and do what you want to.</p> <p>MayPy brings <code>Maybe</code> a wrapper (container), it is either empty if the value passed was <code>None</code> or valuated, in this case it contains the value, and we can perform operation on it.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"changelog/#maypy","title":"Maypy","text":""},{"location":"changelog/#201-2025-05-19","title":"2.0.1 (2025-05-19)","text":""},{"location":"changelog/#bug-fixes","title":"Bug fixes","text":"<ul> <li>map typehint with optional return</li> <li>forbid Some with None value</li> </ul>"},{"location":"changelog/#200-2025-04-07","title":"2.0.0 (2025-04-07)","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>pattern matching</li> <li>type: use callable instead of protocols</li> <li>predicate: add comparisons</li> </ul>"},{"location":"changelog/#113-2025-01-10","title":"1.1.3 (2025-01-10)","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug fixes","text":"<ul> <li>handle missing metadata package</li> </ul>"},{"location":"changelog/#112-2024-10-19","title":"1.1.2 (2024-10-19)","text":""},{"location":"changelog/#bug-fixes_2","title":"Bug fixes","text":"<ul> <li>declare typing support</li> </ul>"},{"location":"changelog/#111-2024-10-19","title":"1.1.1 (2024-10-19)","text":""},{"location":"changelog/#refactoring","title":"Refactoring","text":"<ul> <li>use repr</li> </ul>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>add built-in predicates</li> </ul>"},{"location":"changelog/#100-2024-09-13","title":"1.0.0 (2024-09-13)","text":""},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>add maybe container</li> <li>add functional interfaces</li> </ul>"},{"location":"exceptions/","title":"Exceptions","text":""},{"location":"exceptions/#maypy._exceptions-classes","title":"Classes","text":""},{"location":"exceptions/#maypy._exceptions.EmptyMaybeException","title":"EmptyMaybeException","text":"<p>               Bases: <code>MaybeException</code></p> <p>Exception warning that the maybe contains no value to get.</p>"},{"location":"exceptions/#maypy._exceptions.MaybeException","title":"MaybeException","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for Maybe.</p>"},{"location":"functional/","title":"Functionals","text":""},{"location":"installation/","title":"Installation","text":"<p>Information</p> <p>MayPy is pur Python code with no external dependencies at its core. So don't worry to use it  !</p>"},{"location":"installation/#install-with-pip","title":"Install with pip","text":"pip install maypyinstalled! <p>Tip</p> <p>Don't forget to use a virtual environment when installing library, otherwise it will be installed on your global python environment.</p>"},{"location":"installation/#install-with-poetry","title":"Install with poetry","text":"<p>Information</p> <p>Poetry is a great tools to manage your dependencies and packaging. I highly recommend to check it if you don't know Learn more </p> poetry add maypyInstalling maypywriting lock file"},{"location":"maybe/","title":"Maybe","text":""},{"location":"maybe/#maypy._maybe-classes","title":"Classes","text":""},{"location":"maybe/#maypy._maybe.Empty","title":"Empty","text":"<p>               Bases: <code>Maybe[VALUE]</code></p> <p>Empty Maybe.</p> <p>It doesn't wrap any value.</p>"},{"location":"maybe/#maypy._maybe.Empty-functions","title":"Functions","text":""},{"location":"maybe/#maypy._maybe.Empty.if_present","title":"if_present","text":"<pre><code>if_present(consumer: Callable[[VALUE], None]) -&gt; None\n</code></pre> <p>Do nothing.</p>"},{"location":"maybe/#maypy._maybe.Maybe","title":"Maybe","text":"<p>               Bases: <code>ABC</code>, <code>Generic[VALUE]</code></p> <p>Wrapper class inspired by the well-known Optional API from Java.</p> <p>A Maybe is container, a non-none value may be inside or may be not (hence the name Maybe as an alternative to Optional, which is already used by Python).</p> <p>If a value is present: <code>is_present</code> will return True and <code>get</code> will return the value.</p> <p>It useful when working with data that can be none.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import json\n&gt;&gt;&gt; beer = json.loads(json_beer)\n&gt;&gt;&gt; # Without maybe\n&gt;&gt;&gt; price = beer.get(\"BeerPrice\")\n&gt;&gt;&gt; if price:\n&gt;&gt;&gt;     if price &gt; 0:\n&gt;&gt;&gt;         price = convertDollarsToEuro(price)\n&gt;&gt;&gt; else:\n&gt;&gt;&gt;     raise MyCustomException()\n&gt;&gt;&gt; #  with Maybe\n&gt;&gt;&gt; Maybe.of(beer.get(\"BeerPrice\")).\n&gt;&gt;&gt;     filter(lambda price: price &gt; 0).\n&gt;&gt;&gt;     map(convertDollarsToEuro).\n&gt;&gt;&gt;     or_else_raise(MyCustomException())\n&gt;&gt;&gt;\n</code></pre>"},{"location":"maybe/#maypy._maybe.Maybe-functions","title":"Functions","text":""},{"location":"maybe/#maypy._maybe.Maybe.empty","title":"empty  <code>staticmethod</code>","text":"<pre><code>empty() -&gt; Maybe[Any]\n</code></pre> <p>Returns a empty <code>Maybe</code> instance.</p>"},{"location":"maybe/#maypy._maybe.Maybe.filter","title":"filter  <code>abstractmethod</code>","text":"<pre><code>filter(predicate: Predicate[VALUE]) -&gt; Maybe[VALUE]\n</code></pre> <p>Filter the wrapped value (if present).</p> <p>If it matches the predicate, returns a Maybe describing the value, otherwise return an empty Maybe.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Predicate[VALUE]</code> <p>predicate function to apply to the value.</p> required <p>Returns:</p> Type Description <code>Maybe[VALUE]</code> <p>A Maybe containing the value if it matched the predicate, else an empty Maybe.</p>"},{"location":"maybe/#maypy._maybe.Maybe.get","title":"get  <code>abstractmethod</code>","text":"<pre><code>get() -&gt; VALUE\n</code></pre> <p>Return the value if present, else raise EmptyElementException.</p> <p>Returns:</p> Type Description <code>VALUE</code> <p>The non-None value contained in this Maybe.</p> <p>Raises:</p> Type Description <code>EmptyElementException</code> <p>if no value present.</p>"},{"location":"maybe/#maypy._maybe.Maybe.if_present","title":"if_present  <code>abstractmethod</code>","text":"<pre><code>if_present(consumer: Callable[[VALUE], None]) -&gt; None\n</code></pre> <p>Invoke the given consumer with the value if present, do nothing otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>consumer</code> <code>Callable[[VALUE], None]</code> <p>function to be executed if value present.</p> required"},{"location":"maybe/#maypy._maybe.Maybe.is_empty","title":"is_empty  <code>abstractmethod</code>","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Returns True if value is not present, otherwise False.</p>"},{"location":"maybe/#maypy._maybe.Maybe.is_present","title":"is_present  <code>abstractmethod</code>","text":"<pre><code>is_present() -&gt; bool\n</code></pre> <p>Returns True if value is present, otherwise False.</p>"},{"location":"maybe/#maypy._maybe.Maybe.map","title":"map  <code>abstractmethod</code>","text":"<pre><code>map(mapper: Mapper[VALUE, Optional[OUTPUT]]) -&gt; Maybe[OUTPUT]\n</code></pre> <p>Map the wrapped value (if present).</p> <p>Apply the given mapping function to the value.</p> <p>Parameters:</p> Name Type Description Default <code>mapper</code> <code>Mapper[VALUE, Optional[OUTPUT]]</code> <p>mapping function to apply to the value.</p> required <p>Returns:</p> Type Description <code>Maybe[OUTPUT]</code> <p>A Maybe containing the result of applying the mapping function on the value,</p> <code>Maybe[OUTPUT]</code> <p>if value is present else an empty Maybe.</p>"},{"location":"maybe/#maypy._maybe.Maybe.of","title":"of  <code>staticmethod</code>","text":"<pre><code>of(val: Optional[VALUE]) -&gt; Maybe[VALUE]\n</code></pre> <p>Returns a <code>Maybe</code> instance depends on the value provided.</p> <p>If it's a none value, an empty <code>Maybe</code> will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>Optional[VALUE]</code> <p>the provided value to wrap.</p> required <p>Returns:</p> Type Description <code>Maybe[VALUE]</code> <p>A Maybe containing the value, if non-None value, otherwise an empty Maybe.</p>"},{"location":"maybe/#maypy._maybe.Maybe.or_else","title":"or_else  <code>abstractmethod</code>","text":"<pre><code>or_else(other: Union[VALUE, Supplier[VALUE]]) -&gt; VALUE\n</code></pre> <p>Returns the value if present, else return other.</p> <p>If other is a supplier, it returns the result of the invocation.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[VALUE, Supplier[VALUE]]</code> <p>value to be return if no value present. if other is a supplier function, returns the invocation instead.</p> required <p>Returns:</p> Type Description <code>VALUE</code> <p>The value held by this Maybe if non-None value, otherwise either other or other invocation.</p>"},{"location":"maybe/#maypy._maybe.Maybe.or_else_raise","title":"or_else_raise  <code>abstractmethod</code>","text":"<pre><code>or_else_raise(exception: Exception) -&gt; VALUE\n</code></pre> <p>Returns the value if present, otherwise raise the given exception.</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>Exception</code> <p>The exception to be raised if no value present.</p> required"},{"location":"maybe/#maypy._maybe.Maybe.or_none","title":"or_none  <code>abstractmethod</code>","text":"<pre><code>or_none() -&gt; Optional[VALUE]\n</code></pre> <p>Returns the value if present, else return None.</p> <p>Returns:</p> Type Description <code>Optional[VALUE]</code> <p>The value held by this <code>Maybe</code> if non-None value, otherwise None.</p>"},{"location":"maybe/#maypy._maybe.Some","title":"Some","text":"<p>               Bases: <code>Maybe[VALUE]</code></p> <p>Valuated Maybe.</p>"},{"location":"maybe/#maypy._maybe-functions","title":"Functions","text":""},{"location":"maybe/#maypy._maybe.maybe","title":"maybe","text":"<pre><code>maybe(val: Optional[VALUE]) -&gt; Maybe[VALUE]\n</code></pre> <p>Returns a <code>Maybe</code> instance depends on the value provided.</p> <p>If it's a none value, an empty <code>Maybe</code> will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>Optional[VALUE]</code> <p>the provided value to wrap.</p> required <p>Returns:</p> Type Description <code>Maybe[VALUE]</code> <p>A Maybe containing the value, if non-None value, otherwise an empty Maybe.</p>"},{"location":"predicates/","title":"Predicates","text":""},{"location":"predicates/#maypy.predicates.between","title":"between","text":"<pre><code>between(inf_bound: Comparison, sup_bound: Comparison, exclude: bool = False) -&gt; Predicate[Comparison]\n</code></pre> <p>Returns a between predicate.</p> <p>Corresponding to inf_bound &lt; x &lt; sup_bound if exclude, otherwise inf_bound &lt;= x &lt;= sup_bound.</p>"},{"location":"predicates/#maypy.predicates.contains","title":"contains","text":"<pre><code>contains(*items: T) -&gt; Predicate[Container[T]]\n</code></pre> <p>Returns a predicate to verify if value contains all the items.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; contain = contains(\"1\", \"2\", \"3\")\n&gt;&gt;&gt; assert contain([\"1\", \"2\", \"3\", \"4\"])\n&gt;&gt;&gt; assert contain(\"456123\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>T</code> <p>items to check presence</p> <code>()</code> <p>Raises:     ValueError: if no item has been passed</p>"},{"location":"predicates/#maypy.predicates.equals","title":"equals","text":"<pre><code>equals(expected: T) -&gt; Predicate[T]\n</code></pre> <p>Returns a predicate of equality with the provided value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; equal_maypy = equals(\"maypy\")\n&gt;&gt;&gt; assert equal_maypy(\"maypy\")\n&gt;&gt;&gt; assert not equal_maypy(\"mypy\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>expected</code> <code>T</code> <p>expected equality</p> required"},{"location":"predicates/#maypy.predicates.ge","title":"ge","text":"<pre><code>ge(bound: Comparison) -&gt; Predicate[Comparison]\n</code></pre> <p>Returns a predicate corresponding to x &gt;= bound.</p>"},{"location":"predicates/#maypy.predicates.gt","title":"gt","text":"<pre><code>gt(bound: Comparison) -&gt; Predicate[Comparison]\n</code></pre> <p>Returns a predicate corresponding to x &gt; bound.</p>"},{"location":"predicates/#maypy.predicates.is_blank_str","title":"is_blank_str","text":"<pre><code>is_blank_str(val: str) -&gt; bool\n</code></pre> <p>Checks if the string is either empty or blank.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert is_blank_str(\"\")\n&gt;&gt;&gt; assert is_blank_str(\"   \")\n&gt;&gt;&gt; assert not is_blank_str(\"maypy\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>str</code> <p>string to verify</p> required"},{"location":"predicates/#maypy.predicates.is_empty","title":"is_empty","text":"<pre><code>is_empty(val: Sized) -&gt; bool\n</code></pre> <p>Checks if the element is empty.</p>"},{"location":"predicates/#maypy.predicates.is_falsy","title":"is_falsy","text":"<pre><code>is_falsy(val: T) -&gt; bool\n</code></pre> <p>Check if value is falsy.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert is_falsy(0)\n&gt;&gt;&gt; assert not is_falsy(12)\n</code></pre>"},{"location":"predicates/#maypy.predicates.is_length","title":"is_length","text":"<pre><code>is_length(expected_len: int) -&gt; Predicate[Sized]\n</code></pre> <p>Return a predicate that checks if the len of value equals to the expected length provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_length_at_5 = is_length(5)\n&gt;&gt;&gt; assert is_length_at_5([1,3,3,4,5])\n&gt;&gt;&gt; assert not is_length_at_5({5})\n</code></pre>"},{"location":"predicates/#maypy.predicates.is_truthy","title":"is_truthy","text":"<pre><code>is_truthy(val: T) -&gt; bool\n</code></pre> <p>Check if value is truthy.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert is_truthy(\"maypy\")\n&gt;&gt;&gt; assert not is_truthy(\"\")\n</code></pre>"},{"location":"predicates/#maypy.predicates.le","title":"le","text":"<pre><code>le(bound: Comparison) -&gt; Predicate[Comparison]\n</code></pre> <p>Returns a predicate corresponding to x &lt;= bound.</p>"},{"location":"predicates/#maypy.predicates.lt","title":"lt","text":"<pre><code>lt(bound: Comparison) -&gt; Predicate[Comparison]\n</code></pre> <p>Returns a predicate corresponding to x &lt; bound.</p>"},{"location":"predicates/#maypy.predicates.match_regex","title":"match_regex","text":"<pre><code>match_regex(regex: Union[re.Pattern[str], str], flags: Union[re.RegexFlag, int] = 0) -&gt; Predicate[str]\n</code></pre> <p>Returns a predicate that checks if value match the regex pattern provided.</p> <p>Parameters:</p> Name Type Description Default <code>regex</code> <code>Union[Pattern[str], str]</code> <p>regex to match (either a string or a Pattern)</p> required <code>flags</code> <code>Union[RegexFlag, int]</code> <p>regex flags; should bot be passed with a pattern.</p> <code>0</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>when passing flags whereas a <code>Pattern</code> have been passed</p>"},{"location":"predicates/#maypy.predicates.neg","title":"neg","text":"<pre><code>neg(predicate: Predicate[T]) -&gt; Predicate[T]\n</code></pre> <p>Create a new predicate that is the negation of the provided.</p> <p>If the predicate would yield True, the negated one would yield False, and vice versa.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; assert maybe(\"maypy\").filter(is_blank_str).is_empty()\n&gt;&gt;&gt; assert maybe(\"maypy\").filter(neg(is_blank_str)).is_present()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Predicate[T]</code> <p>preddicate to negate</p> required <p>Returns:</p> Type Description <code>Predicate[T]</code> <p>Negate predicate of the provided</p>"},{"location":"predicates/#maypy.predicates.one_of","title":"one_of","text":"<pre><code>one_of(options: Container[T]) -&gt; Predicate[T]\n</code></pre> <p>Returns a predicate to check if value is one of these options.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; option = one_of([\"foo\", \"bar\"])\n&gt;&gt;&gt; assert option(\"foo\")\n&gt;&gt;&gt; assert option(\"bar\")\n&gt;&gt;&gt; assert not option(\"maypy\")\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>The purpose of MayPy is to provide a type-level solution for representing and manipulating optional values instead of None reference. This away around, no need to worry about the optional value and testing it, before applying process on it.</p> <p>There are two types of Maybe container, either it contains a value or it is empty.</p> <p>A Maybe object become empty when the value it should contain is <code>None</code>.</p>"},{"location":"usage/#create-maybe-objects","title":"Create Maybe objects","text":""},{"location":"usage/#empty","title":"Empty","text":"<p>There are 3 ways to have a empty Maybe.</p> <pre><code>from maypy import EMPTY, Empty, maybe\n\nassert maybe(None) == Empty() == EMPTY\n</code></pre> <p>Note</p> <p><code>maybe(None)</code> is here as an example, for readability use the others to instantiate an empty Maybe.</p>"},{"location":"usage/#valuated","title":"Valuated","text":"<p>Valuated Maybe or <code>Some</code>, is quite straightforward, provide some value whatever it is, as long as is not <code>None</code> to <code>of</code> .</p> <pre><code>assert maybe(12)\n</code></pre>"},{"location":"usage/#checking-value-presence","title":"Checking value presence","text":"<p>There are three methods to check if the value is present or not.</p> <p>Either by using <code>is_present</code> to know if the container has a value  or use <code>is_empty</code> to verify the absence of value. Another approach is to examine the \"truthiness\" of Maybe.</p> is_presentis_emptytruthiness <pre><code>name = maybe(\"name\")\nassert name.is_present()\n\nname = Empty()\nassert not name.is_present()\n</code></pre> <pre><code>name = maybe(\"name\")\nassert not name.is_empty()\n\nname = Empty()\nassert name.is_empty()\n</code></pre> <pre><code>assert maybe(\"name\")\n\nassert not Empty()\n</code></pre>"},{"location":"usage/#get-wrapped-value","title":"Get wrapped value","text":"<p>To retrieve the value contained inside a Maybe, the method <code>get</code> returns it or raises an <code>EmptyMaybeException</code>.</p> <pre><code>assert maybe(\"Mathieu\").get() == \"Mathieu\"\nassert Empty().get()\n&gt;&gt;&gt; EmptyMaybeException\n</code></pre>"},{"location":"usage/#handle-emptiness","title":"Handle Emptiness","text":""},{"location":"usage/#default-value","title":"Default value","text":"<p>When Maybe is empty, it's possible to provide a default value using <code>or_else</code>. Taking either a value or a <code>Supplier</code>  (with mypy the value provide as default should be the same type as the hypothetical value wrapped).</p> by valueby Supplier <pre><code>assert Maybe.empty().or_else(12) == 12\n\nassert maybe(\"present\").or_else(\"absent\") == \"present\"\n</code></pre> <p>Warning</p> <p>It is indeed possible to do this way in pur python.</p> <pre><code>assert (\"present\" or \"absent) == \"present\"\n\nassert (None or 12) == 12\n</code></pre> <p>However, it is using the \"truthiness\" of the first element, it does not mean that the element is None!</p> <pre><code>&gt;&gt;&gt; assert (0 or 12) == 0\n&gt;&gt;&gt; AssertionError\n</code></pre> <pre><code>assert Maybe.empty().or_else(lambda: 12) == 12\n\nassert maybe(\"present\").or_else(lambda: \"absent\") == \"present\"\n</code></pre> <p>Tips</p> <p>We may wonder what is the different between passing the function and calling it as the default value. The function is used only if Maybe is empty, whereas in the other hands, it will be invoked no matter what.</p> <pre><code>def populate_data() -&gt; list[str]:\n    print(\"invocation of populate_data\")\n    return [\"python\", \"c++\", \"c\", \"java\"]\n\nassert Maybe.empty().or_else(populate_data) == [\"python\", \"c++\", \"c\", \"java\"]\n&gt;&gt;&gt; \"invocation of populate_data\"\nassert maybe([\"ruby\", \"kotlin\"]).or_else(populate_data) == [\"ruby\", \"kotlin\"]\nassert maybe([\"ruby\", \"kotlin\"]).or_else(populate_data()) == [\"ruby\", \"kotlin\"]\n&gt;&gt;&gt; \"invocation of populate_data\"\n</code></pre>"},{"location":"usage/#raise-error","title":"Raise error","text":"<p>Another approach for handling value absence, is to raise a custom exception by  <code>or_else_raise</code> when Maybe is empty.</p> <pre><code>class CustomError(Exception):\n    pass\n\nassert Maybe.empty().or_else_raise(CustomError())\n&gt;&gt;&gt; CustomError\nassert maybe(12).or_else_raise(CustomError()) == 12\n</code></pre>"},{"location":"usage/#manipulating-the-value","title":"Manipulating the value","text":"<p>Note</p> <p>In the further examples, I keep using lambda function to keep it simple and easy to read. It totally possible to use named function, no matter what you use as long as it respects the API contract.</p> <p>By the way <code>mypy</code> will infer types even with lambda !!!</p>"},{"location":"usage/#filtering","title":"Filtering","text":"<p>It is possible to perform inline condition on our wrapped value with <code>filter</code>. Taking a <code>Predicate</code>, it will check if the value matches the predicate and returning Maybe itself when passing, otherwise an empty Maybe is returned.</p>"},{"location":"usage/#built-in-predicates","title":"Built-in Predicates","text":"<p>1.1.0</p> <p>Some built-in predicates have been added.</p> <pre><code>price = 999.99\n\nassert maybe(price).filter(lambda x: x &lt;= 1000).is_present()\nassert maybe(price).filter(lambda x: x &gt;= 1000).is_empty()\n</code></pre> <p>You may wonder why using it and what is the gain. Let's dive on a more concrete example!</p> <p>You want to watch a movie, and you ony care about its release date. It should be in certain interval.</p> <pre><code>from dataclasses import dataclass, field\n\n@dataclass\nclass Movie:\n    director: str\n    title: str\n    year: int\n    genre: list[str] = field(default_factory=list)\n    oscars: list[str] | None = field(default=None)\n</code></pre> without Maybewith Maybe <pre><code>from typing import Callable\n\ndef interval_checker(start_year: int, end_year: int) -&gt; Callable[[Movie], bool]:\n    def is_in_range(movie: Movie | None) -&gt; bool:\n        if movie is not None:\n            return start_year &lt;= movie.year &lt;= end_year\n        return False\n\n    return is_in_range\n\n\nmovie = Movie(\"Luc Besson\", \"Taxi\", 1998, [\"comedy\"])\n\nassert interval_checker(1990, 2005)(movie)\nassert not interval_checker(2000, 2020)(movie)\nassert not interval_checker(2000, 2020)(None)\n</code></pre> <pre><code>from maypy import Maybe\n\nassert maybe(movie).filter(lambda film: 1990 &lt;= film.year &lt;= 2005).is_present()\n</code></pre>"},{"location":"usage/#mapping","title":"Mapping","text":"<p>With a similar syntax, we can transform the value inside Maybe using  <code>map</code>.</p> <p>Reusing last example, getting the number of oscars rewarding the movie.</p> <pre><code>movie = Movie(\"Luc Besson\", \"Taxi\", 1998, [\"comedy\"])\n\nassert (\n        maybe(movie)\n        .map(lambda film: movie.oscars)\n        .map(lambda oscars: len(oscars))\n        .or_else(0) == 0\n)\n</code></pre> <p>It is powerful to chain filter and map together. Like checking the correctness of an input by a user.</p> <pre><code>from maypy.predicates import one_of\n\nVALID_BOOLS = (\"y\", \"n\", \"yes\", \"no\")\n\nuser_input = \"y \"\n\nassert (\n    maybe(user_input)\n    .map(lambda input_: input_.strip())\n    .filter(one_of(VALID_BOOLS))\n    .is_present()\n)\n</code></pre>"},{"location":"usage/#conditional-action","title":"Conditional action","text":"<p>The last method is <code>if_present</code>, it allows to perform some code, using a <code>Consumer</code> function (<code>Callable[[VALUE], None]</code>), on the wrapped value if present, otherwise nothing will happen.</p> <pre><code>maybe(\"name\").if_present(lambda val: print(val))\n</code></pre> <p>Warning</p> <p>To keep it functional, the function passed should not modify the value but only use it. Please use chaining of <code>map</code> and get the value instead.</p>"}]}